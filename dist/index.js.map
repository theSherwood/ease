{
  "version": 3,
  "sources": ["../src/fridx.ts", "../src/storage.ts", "../src/types.ts", "../src/audioPlayer.ts", "../src/music.ts", "../src/state.ts", "../src/events.ts", "../src/vdom.ts", "../src/index.ts"],
  "sourcesContent": ["// https://github.com/rocicorp/fractional-indexing/blob/main/src/index.js\n\n// License: CC0 (no rights reserved).\n\n// This is based on https://observablehq.com/@dgreensp/implementing-fractional-indexing\n\nexport const BASE_62_DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\n// `a` may be empty string, `b` is null or non-empty string.\n// `a < b` lexicographically if `b` is non-null.\n// no trailing zeros allowed.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string} a\n * @param {string | null | undefined} b\n * @param {string} digits\n * @returns {string}\n */\nfunction midpoint(a, b, digits) {\n  const zero = digits[0];\n  if (b != null && a >= b) {\n    throw new Error(a + ' >= ' + b);\n  }\n  if (a.slice(-1) === zero || (b && b.slice(-1) === zero)) {\n    throw new Error('trailing zero');\n  }\n  if (b) {\n    // remove longest common prefix.  pad `a` with 0s as we\n    // go.  note that we don't need to pad `b`, because it can't\n    // end before `a` while traversing the common prefix.\n    let n = 0;\n    while ((a[n] || zero) === b[n]) {\n      n++;\n    }\n    if (n > 0) {\n      return b.slice(0, n) + midpoint(a.slice(n), b.slice(n), digits);\n    }\n  }\n  // first digits (or lack of digit) are different\n  const digitA = a ? digits.indexOf(a[0]) : 0;\n  const digitB = b != null ? digits.indexOf(b[0]) : digits.length;\n  if (digitB - digitA > 1) {\n    const midDigit = Math.round(0.5 * (digitA + digitB));\n    return digits[midDigit];\n  } else {\n    // first digits are consecutive\n    if (b && b.length > 1) {\n      return b.slice(0, 1);\n    } else {\n      // `b` is null or has length 1 (a single digit).\n      // the first digit of `a` is the previous digit to `b`,\n      // or 9 if `b` is null.\n      // given, for example, midpoint('49', '5'), return\n      // '4' + midpoint('9', null), which will become\n      // '4' + '9' + midpoint('', null), which is '495'\n      return digits[digitA] + midpoint(a.slice(1), null, digits);\n    }\n  }\n}\n\n/**\n * @param {string} int\n * @return {void}\n */\n\nfunction validateInteger(int) {\n  if (int.length !== getIntegerLength(int[0])) {\n    throw new Error('invalid integer part of order key: ' + int);\n  }\n}\n\n/**\n * @param {string} head\n * @return {number}\n */\n\nfunction getIntegerLength(head) {\n  if (head >= 'a' && head <= 'z') {\n    return head.charCodeAt(0) - 'a'.charCodeAt(0) + 2;\n  } else if (head >= 'A' && head <= 'Z') {\n    return 'Z'.charCodeAt(0) - head.charCodeAt(0) + 2;\n  } else {\n    throw new Error('invalid order key head: ' + head);\n  }\n}\n\n/**\n * @param {string} key\n * @return {string}\n */\n\nfunction getIntegerPart(key) {\n  const integerPartLength = getIntegerLength(key[0]);\n  if (integerPartLength > key.length) {\n    throw new Error('invalid order key: ' + key);\n  }\n  return key.slice(0, integerPartLength);\n}\n\n/**\n * @param {string} key\n * @param {string} digits\n * @return {void}\n */\n\nfunction validateOrderKey(key, digits) {\n  if (key === 'A' + digits[0].repeat(26)) {\n    throw new Error('invalid order key: ' + key);\n  }\n  // getIntegerPart will throw if the first character is bad,\n  // or the key is too short.  we'd call it to check these things\n  // even if we didn't need the result\n  const i = getIntegerPart(key);\n  const f = key.slice(i.length);\n  if (f.slice(-1) === digits[0]) {\n    throw new Error('invalid order key: ' + key);\n  }\n}\n\n// note that this may return null, as there is a largest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\nfunction incrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split('');\n  let carry = true;\n  for (let i = digs.length - 1; carry && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) + 1;\n    if (d === digits.length) {\n      digs[i] = digits[0];\n    } else {\n      digs[i] = digits[d];\n      carry = false;\n    }\n  }\n  if (carry) {\n    if (head === 'Z') {\n      return 'a' + digits[0];\n    }\n    if (head === 'z') {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) + 1);\n    if (h > 'a') {\n      digs.push(digits[0]);\n    } else {\n      digs.pop();\n    }\n    return h + digs.join('');\n  } else {\n    return head + digs.join('');\n  }\n}\n\n// note that this may return null, as there is a smallest integer\n/**\n * @param {string} x\n * @param {string} digits\n * @return {string | null}\n */\n\nfunction decrementInteger(x, digits) {\n  validateInteger(x);\n  const [head, ...digs] = x.split('');\n  let borrow = true;\n  for (let i = digs.length - 1; borrow && i >= 0; i--) {\n    const d = digits.indexOf(digs[i]) - 1;\n    if (d === -1) {\n      digs[i] = digits.slice(-1);\n    } else {\n      digs[i] = digits[d];\n      borrow = false;\n    }\n  }\n  if (borrow) {\n    if (head === 'a') {\n      return 'Z' + digits.slice(-1);\n    }\n    if (head === 'A') {\n      return null;\n    }\n    const h = String.fromCharCode(head.charCodeAt(0) - 1);\n    if (h < 'Z') {\n      digs.push(digits.slice(-1));\n    } else {\n      digs.pop();\n    }\n    return h + digs.join('');\n  } else {\n    return head + digs.join('');\n  }\n}\n\n// `a` is an order key or null (START).\n// `b` is an order key or null (END).\n// `a < b` lexicographically if both are non-null.\n// digits is a string such as '0123456789' for base 10.  Digits must be in\n// ascending character code order!\n/**\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {string=} digits\n * @return {string}\n */\nexport function generateKeyBetween(a, b, digits = BASE_62_DIGITS) {\n  if (a != null) {\n    validateOrderKey(a, digits);\n  }\n  if (b != null) {\n    validateOrderKey(b, digits);\n  }\n  if (a != null && b != null && a >= b) {\n    throw new Error(a + ' >= ' + b);\n  }\n  if (a == null) {\n    if (b == null) {\n      return 'a' + digits[0];\n    }\n\n    const ib = getIntegerPart(b);\n    const fb = b.slice(ib.length);\n    if (ib === 'A' + digits[0].repeat(26)) {\n      return ib + midpoint('', fb, digits);\n    }\n    if (ib < b) {\n      return ib;\n    }\n    const res = decrementInteger(ib, digits);\n    if (res == null) {\n      throw new Error('cannot decrement any more');\n    }\n    return res;\n  }\n\n  if (b == null) {\n    const ia = getIntegerPart(a);\n    const fa = a.slice(ia.length);\n    const i = incrementInteger(ia, digits);\n    return i == null ? ia + midpoint(fa, null, digits) : i;\n  }\n\n  const ia = getIntegerPart(a);\n  const fa = a.slice(ia.length);\n  const ib = getIntegerPart(b);\n  const fb = b.slice(ib.length);\n  if (ia === ib) {\n    return ia + midpoint(fa, fb, digits);\n  }\n  const i = incrementInteger(ia, digits);\n  if (i == null) {\n    throw new Error('cannot increment any more');\n  }\n  if (i < b) {\n    return i;\n  }\n  return ia + midpoint(fa, null, digits);\n}\n\n/**\n * same preconditions as generateKeysBetween.\n * n >= 0.\n * Returns an array of n distinct keys in sorted order.\n * If a and b are both null, returns [a0, a1, ...]\n * If one or the other is null, returns consecutive \"integer\"\n * keys.  Otherwise, returns relatively short keys between\n * a and b.\n * @param {string | null | undefined} a\n * @param {string | null | undefined} b\n * @param {number} n\n * @param {string} digits\n * @return {string[]}\n */\nexport function generateNKeysBetween(a, b, n, digits = BASE_62_DIGITS) {\n  if (n === 0) {\n    return [];\n  }\n  if (n === 1) {\n    return [generateKeyBetween(a, b, digits)];\n  }\n  if (b == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(c, b, digits);\n      result.push(c);\n    }\n    return result;\n  }\n  if (a == null) {\n    let c = generateKeyBetween(a, b, digits);\n    const result = [c];\n    for (let i = 0; i < n - 1; i++) {\n      c = generateKeyBetween(a, c, digits);\n      result.push(c);\n    }\n    result.reverse();\n    return result;\n  }\n  const mid = Math.floor(n / 2);\n  const c = generateKeyBetween(a, b, digits);\n  return [\n    ...generateNKeysBetween(a, c, mid, digits),\n    c,\n    ...generateNKeysBetween(c, b, n - mid - 1, digits),\n  ];\n}\n", "import { Audio, SessionSegment, Task } from './types';\n\nconst DB_VERSION = 1;\n\nexport const EASE_STORE = 'ease_store';\n\nconst TASKS_STORE = 'tasks';\nconst AUDIO_STORE = 'audio';\nconst SESSION_SEGMENTS_STORE = 'sessionSegments';\n\nlet maxTaskId = 0;\nlet maxAudioId = 0;\nlet maxSessionId = 0;\nexport function getTaskId() {\n  return ++maxTaskId;\n}\nexport function getAudioId() {\n  return ++maxAudioId;\n}\nexport function getSessionId() {\n  return ++maxSessionId;\n}\n\nexport function getColumnMax(db: IDBDatabase, storeName: string, column: string): Promise<number> {\n  return new Promise((resolve, reject) => {\n    let store;\n    try {\n      const transaction = db.transaction(storeName, 'readonly');\n      store = transaction.objectStore(storeName);\n    } catch (e) {\n      console.warn(e);\n      resolve(0);\n    }\n    let index = store.index(column);\n    // Use the .openCursor() method with descending order on the primary key\n    const request = index.openCursor(null, 'prev');\n    request.onsuccess = (event) => {\n      const cursor = event.target.result;\n      if (cursor) {\n        resolve(cursor.value[column]); // Max value\n      } else {\n        resolve(0); // No records found\n      }\n    };\n    request.onerror = () => reject(`Error retrieving max \"${column}\"`);\n  });\n}\n\ninterface HasId {\n  id?: number;\n}\n\nexport class ListStore<T extends HasId> {\n  db: IDBDatabase;\n  storeName: string;\n  constructor(storeName: string) {\n    this.storeName = storeName;\n  }\n\n  connect(db: IDBDatabase) {\n    this.db = db;\n  }\n\n  async add(record: T): Promise<void> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readwrite');\n      const store = tx.objectStore(this.storeName);\n      store.add(record);\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  async bulkAdd(records: T[]): Promise<void> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readwrite');\n      const store = tx.objectStore(this.storeName);\n      for (const record of records) {\n        store.add(record);\n      }\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  async upsert(record: Partial<T>): Promise<void> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readwrite');\n      const store = tx.objectStore(this.storeName);\n      store.put(record);\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  async get(id: number): Promise<T | null> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readonly');\n      const store = tx.objectStore(this.storeName);\n      const request = store.get(id);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result || null);\n    });\n  }\n\n  async getAll(): Promise<T[]> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readonly');\n      const store = tx.objectStore(this.storeName);\n      const request = store.getAll();\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async delete(id: number): Promise<void> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readwrite');\n      const store = tx.objectStore(this.storeName);\n      store.delete(id);\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  async clear(): Promise<void> {\n    const db = this.db!;\n    return new Promise((resolve, reject) => {\n      const tx = db.transaction(this.storeName, 'readwrite');\n      const store = tx.objectStore(this.storeName);\n      store.clear();\n      tx.oncomplete = () => resolve();\n      tx.onerror = () => reject(tx.error);\n    });\n  }\n\n  async *iterate(): AsyncGenerator<T> {\n    const db = this.db!;\n    const tx = db.transaction(this.storeName, 'readonly');\n    const store = tx.objectStore(this.storeName);\n    const request = store.openCursor();\n\n    let cursor: IDBCursorWithValue | null = await new Promise((resolve) => {\n      request.onsuccess = () => resolve(request.result);\n    });\n\n    while (cursor) {\n      yield cursor.value;\n      cursor = await new Promise((resolve) => {\n        cursor!.continue();\n        request.onsuccess = () => resolve(request.result);\n      });\n    }\n  }\n}\n\nexport const taskStore = new ListStore<Task>(TASKS_STORE);\nexport const audioStore = new ListStore<Audio>(AUDIO_STORE);\nexport const sessionSegmentStore = new ListStore<SessionSegment>(SESSION_SEGMENTS_STORE);\n\nconst options = {\n  [TASKS_STORE]: { indexes: [{ name: 'id', unique: true }] },\n  [AUDIO_STORE]: { indexes: [{ name: 'id', unique: true }] },\n  [SESSION_SEGMENTS_STORE]: { indexes: [{ name: 'sessionId', unique: false }] },\n};\n\nexport async function setupStore() {\n  let db: IDBDatabase;\n  const setupDb = new Promise((resolve, reject) => {\n    const request = indexedDB.open(EASE_STORE, DB_VERSION);\n\n    request.onerror = () => reject(request.error);\n    request.onsuccess = () => {\n      db = request.result;\n      resolve(request.result);\n    };\n\n    request.onupgradeneeded = (event) => {\n      db = (event.target as IDBOpenDBRequest).result;\n      for (const storeName of [TASKS_STORE, AUDIO_STORE, SESSION_SEGMENTS_STORE]) {\n        console.log('onupgradeneeded', storeName, options);\n        if (!db.objectStoreNames.contains(storeName)) {\n          let store = db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });\n          for (const { name, unique } of options[storeName].indexes) {\n            if (!store.indexNames.contains(name)) {\n              store.createIndex(name, name, { unique });\n            }\n          }\n        }\n      }\n    };\n  });\n  await setupDb;\n\n  taskStore.connect(db!);\n  audioStore.connect(db!);\n  sessionSegmentStore.connect(db!);\n  console.log('Object Stores:', Array.from(db!.objectStoreNames));\n\n  let id = await getColumnMax(taskStore.db!, 'tasks', 'id');\n  if (id > maxTaskId) maxTaskId = id;\n  id = await getColumnMax(audioStore.db!, 'audio', 'id');\n  if (id > maxAudioId) maxAudioId = id;\n  id = await getColumnMax(sessionSegmentStore.db!, 'sessionSegments', 'sessionId');\n  if (id > maxSessionId) maxSessionId = id;\n\n  console.log('maxTaskId', maxTaskId);\n  console.log('maxAudioId', maxAudioId);\n  console.log('maxSessionSegmentId', maxSessionId);\n}\n", "export const TASK_SESSION = 0;\nexport const TASK_RECURRING = 1;\nexport const TASK_COMPLETED = 2;\n\nexport type TaskStatus = typeof TASK_SESSION | typeof TASK_RECURRING | typeof TASK_COMPLETED;\n\nexport type Task = {\n  id: number;\n  description: string;\n  status: TaskStatus;\n  timeEstimate: number;\n  timeRemaining: number;\n  timeElapsed: number;\n  checkpoint: number;\n  createdAt: number;\n  completedAt: number;\n  fridx: string;\n};\n\nexport type TaskList = { list: Task[] };\n\nexport type Audio = {\n  id: number;\n  name: string;\n  data: Blob;\n  type: string;\n  lastModified: number;\n};\n\nexport const AUDIO_FINISHED = 0;\nexport const AUDIO_ABORTED = 1;\nexport type AudioEndKind = typeof AUDIO_FINISHED | typeof AUDIO_ABORTED;\n\nexport type SessionKind = typeof APP_ACTIVE | typeof APP_BREAK;\n\nexport type SessionSegment = {\n  id?: number;\n  sessionId: number;\n  kind: SessionKind;\n  start: number;\n  end: number;\n};\n\nexport const APP_IDLE = 0;\nexport const APP_ACTIVE = 1;\nexport const APP_BREAK = 2;\n\nexport type AppStatus = typeof APP_ACTIVE | typeof APP_BREAK | typeof APP_IDLE;\n\nexport type AppState = {\n  tabId: string;\n  tabs: string[];\n  leader: string;\n\n  status: AppStatus;\n  sessionId: number;\n  checkpoint: number;\n  countup: boolean;\n  pomodoroDuration: number;\n  breakDuration: number;\n  speaker: string;\n\n  audioUploadState: number;\n  draggingFile: boolean;\n\n  sessionTasks: TaskList;\n  recurringTasks: TaskList;\n  completedTasks: TaskList;\n};\n", "import { AUDIO_ABORTED, AUDIO_FINISHED, AudioEndKind } from './types';\n\nexport class AudioPlayer {\n  private audio: HTMLAudioElement | null = null;\n  private currentResolver: ((AudioEndKind) => void) | null = null;\n\n  play(audioUrl: string): Promise<AudioEndKind> {\n    console.log('PLAY:', audioUrl);\n    // Stop any existing audio\n    this.stop();\n\n    return new Promise((resolve, reject) => {\n      this.currentResolver = resolve;\n      this.audio = new Audio(audioUrl);\n\n      // Handle natural completion\n      this.audio.addEventListener('ended', () => {\n        this.currentResolver?.(AUDIO_FINISHED);\n        this.currentResolver = null;\n        this.audio = null;\n      });\n\n      // Start playback\n      this.audio.play().catch((error) => {\n        reject(error);\n        this.currentResolver = null;\n        this.audio = null;\n      });\n    });\n  }\n\n  stop(): void {\n    if (this.audio) {\n      this.audio.pause();\n      this.audio.currentTime = 0;\n      this.currentResolver?.(AUDIO_ABORTED);\n      this.currentResolver = null;\n      this.audio = null;\n    }\n  }\n\n  setVolume(volume: number): void {\n    if (this.audio) {\n      this.audio.volume = volume;\n    }\n  }\n}\n\nconst speechPlayer = new AudioPlayer();\nconst musicPlayer = new AudioPlayer();\n\nexport async function playSpeech(audioUrl: string) {\n  musicPlayer.setVolume(0.5);\n  let res = await speechPlayer.play(audioUrl);\n  musicPlayer.setVolume(1);\n  return res;\n}\nexport async function playMusic(audioUrl: string) {\n  return musicPlayer.play(audioUrl);\n}\n\nexport function stopSpeech() {\n  speechPlayer.stop();\n}\nexport function stopMusic() {\n  musicPlayer.stop();\n}\n", "import { playMusic } from './audioPlayer';\nimport { audioStore, getAudioId } from './storage';\nimport { Audio, AUDIO_ABORTED } from './types';\n\nexport type ProcessOptions = {\n  normalize?: boolean;\n  trim?: boolean;\n  fadeIn?: number;\n  fadeOut?: number;\n};\n\nfunction getPeakValue(buffer: AudioBuffer): number {\n  let peak = 0;\n  for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n    const data = buffer.getChannelData(channel);\n    for (let i = 0; i < data.length; i++) {\n      peak = Math.max(peak, Math.abs(data[i]));\n    }\n  }\n  return peak;\n}\n\nfunction normalizeAudio(\n  ctx: OfflineAudioContext,\n  source: AudioBufferSourceNode,\n  peak: number,\n): AudioNode {\n  const gain = ctx.createGain();\n  gain.gain.value = peak > 0 ? 1 / peak : 1;\n  source.connect(gain);\n  return gain;\n}\n\nfunction addFadeIn(ctx: OfflineAudioContext, source: AudioNode, duration: number): AudioNode {\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(0, 0);\n  gain.gain.linearRampToValueAtTime(1, duration);\n  source.connect(gain);\n  return gain;\n}\n\nfunction addFadeOut(\n  ctx: OfflineAudioContext,\n  source: AudioNode,\n  duration: number,\n  totalDuration: number,\n): AudioNode {\n  const gain = ctx.createGain();\n  gain.gain.setValueAtTime(1, totalDuration - duration);\n  gain.gain.linearRampToValueAtTime(0, totalDuration);\n  source.connect(gain);\n  return gain;\n}\n\nfunction audioBufferToBlob(audioBuffer: AudioBuffer): Blob {\n  const numOfChannels = audioBuffer.numberOfChannels;\n  const sampleRate = audioBuffer.sampleRate;\n  const format = 1; // PCM\n  const bitDepth = 16;\n\n  let numOfFrames = audioBuffer.length;\n  let buffer = new ArrayBuffer(44 + numOfFrames * numOfChannels * 2);\n  let view = new DataView(buffer);\n\n  // WAV HEADER (unchanged)\n  writeString(view, 0, 'RIFF');\n  view.setUint32(4, 36 + numOfFrames * numOfChannels * 2, true);\n  writeString(view, 8, 'WAVE');\n  writeString(view, 12, 'fmt ');\n  view.setUint32(16, 16, true);\n  view.setUint16(20, format, true);\n  view.setUint16(22, numOfChannels, true);\n  view.setUint32(24, sampleRate, true);\n  view.setUint32(28, sampleRate * numOfChannels * 2, true);\n  view.setUint16(32, numOfChannels * 2, true);\n  view.setUint16(34, bitDepth, true);\n  writeString(view, 36, 'data');\n  view.setUint32(40, numOfFrames * numOfChannels * 2, true);\n\n  // PCM Data - Properly interleaved\n  let offset = 44;\n  const channels: Float32Array[] = [];\n  for (let i = 0; i < numOfChannels; i++) {\n    channels[i] = audioBuffer.getChannelData(i);\n  }\n\n  // Write interleaved data\n  for (let i = 0; i < numOfFrames; i++) {\n    for (let channel = 0; channel < numOfChannels; channel++) {\n      let sample = Math.max(-1, Math.min(1, channels[channel][i]));\n      sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;\n      view.setInt16(offset, sample, true);\n      offset += 2;\n    }\n  }\n\n  return new Blob([buffer], { type: 'audio/wav' });\n}\n\n// Helper function to write strings to DataView\nfunction writeString(view, offset, text) {\n  for (let i = 0; i < text.length; i++) {\n    view.setUint8(offset + i, text.charCodeAt(i));\n  }\n}\n\nasync function processAudio(buffer: AudioBuffer, options: ProcessOptions): Promise<Blob> {\n  const ctx = new OfflineAudioContext(buffer.numberOfChannels, buffer.length, buffer.sampleRate);\n\n  const source = ctx.createBufferSource();\n  source.buffer = buffer;\n  let node: AudioNode = source;\n  if (options.normalize) node = normalizeAudio(ctx, source, getPeakValue(buffer));\n  if (options.fadeIn) node = addFadeIn(ctx, node, options.fadeIn);\n  if (options.fadeOut) node = addFadeOut(ctx, node, options.fadeOut, buffer.duration);\n\n  node.connect(ctx.destination);\n  source.start();\n\n  const renderedBuffer = await ctx.startRendering();\n  return audioBufferToBlob(renderedBuffer);\n}\n\nexport async function processAudioFile(file: File, options: ProcessOptions): Promise<Audio> {\n  const audioContext = new AudioContext();\n  const arrayBuffer = await file.arrayBuffer();\n  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);\n  const processed = await processAudio(audioBuffer, options);\n  return {\n    id: -1,\n    name: file.name,\n    type: file.type,\n    data: processed,\n    lastModified: Date.now(),\n  };\n}\n\nexport async function storeAudio(config: Audio) {\n  config.id = getAudioId();\n  await audioStore.add(config);\n}\n\nasync function playAudioAsMusic(audio: Audio) {\n  // Create blob URL from stored data\n  const blob = new Blob([audio.data], { type: audio.type });\n  const audioUrl = URL.createObjectURL(blob);\n  let res = await playMusic(audioUrl);\n  URL.revokeObjectURL(audioUrl);\n  return res;\n}\n\nexport async function playShuffledAudio() {\n  while (true) {\n    const music = await audioStore.getAll();\n    const shuffledMusic = music.sort(() => Math.random() - 0.5);\n    if (shuffledMusic.length === 0) return;\n    for (const m of shuffledMusic) {\n      let res = await playAudioAsMusic(m);\n      if (res === AUDIO_ABORTED) return;\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n  }\n}\n\nexport function uploadAudioFiles(callback: (files: File[]) => void) {\n  return async (event: Event) => {\n    event.preventDefault();\n    let files: File[] = [];\n    if (event instanceof DragEvent && event.dataTransfer) {\n      files = await extractAudioFiles(event.dataTransfer.items);\n    } else if (event.target instanceof HTMLInputElement && event.target.files) {\n      files = await extractAudioFiles(event.target.files);\n    }\n    console.log('files', files);\n    return callback(files);\n  };\n}\n\nfunction isAudioFile(file: File): boolean {\n  return file.name.endsWith('.mp3') || file.name.endsWith('.wav');\n}\n\nasync function extractAudioFiles(items: DataTransferItemList | FileList): Promise<File[]> {\n  let audioFiles: File[] = [];\n  if (items instanceof DataTransferItemList) {\n    for (const item of items) {\n      if (item.kind === 'file') {\n        const entry = item.webkitGetAsEntry();\n        if (entry) await traverseFileTree(entry, audioFiles);\n      }\n    }\n  } else if (items instanceof FileList) {\n    for (const item of items) {\n      if (isAudioFile(item)) audioFiles.push(item);\n    }\n  }\n  return audioFiles;\n}\n\nasync function traverseFileTree(entry: FileSystemEntry, files: File[]) {\n  if (entry.isFile) {\n    const file = await getFile(entry as FileSystemFileEntry);\n    if (isAudioFile(file)) {\n      files.push(file);\n    }\n  } else if (entry.isDirectory) {\n    const reader = (entry as FileSystemDirectoryEntry).createReader();\n    let entries = await readEntries(reader);\n    for (const subEntry of entries) {\n      await traverseFileTree(subEntry, files);\n    }\n  }\n}\n\nfunction getFile(entry: FileSystemFileEntry): Promise<File> {\n  return new Promise((resolve) => entry.file(resolve));\n}\n\nfunction readEntries(reader: FileSystemDirectoryReader): Promise<FileSystemEntry[]> {\n  return new Promise((resolve) => reader.readEntries(resolve));\n}\n", "import { APP_IDLE, AppState, AppStatus, TaskList } from './types';\n\nconst POMODORO_DURATION_DEFAULT = 25 * 60;\nconst BREAK_DURATION_DEFAULT = 5 * 60;\nconst COUNTUP_DEFAULT = false;\n// const SPEAKER_DEFAULT = 'johnny_cash';\nconst SPEAKER_DEFAULT = 'rick_sanchez';\nexport const SESSION_ID_DEFAULT = -1;\n\nexport const sessionTasks: TaskList = { list: [] };\nexport const recurringTasks: TaskList = { list: [] };\nexport const completedTasks: TaskList = { list: [] };\n\nconst tabId = Math.random().toString(36);\n\nexport const appState: AppState = {\n  // Tab coordination\n  tabId,\n  tabs: [tabId],\n  leader: '',\n\n  // Stored in localStorage\n  status: 0,\n  checkpoint: 0,\n  pomodoroDuration: 0,\n  breakDuration: 0,\n  sessionId: SESSION_ID_DEFAULT,\n  countup: false,\n  speaker: '',\n\n  // Local state\n  audioUploadState: 1,\n  draggingFile: false,\n\n  // Task data\n  sessionTasks,\n  recurringTasks,\n  completedTasks,\n};\nreadFromLocalStorageUnsafe();\n\nfunction boolFromString(value: string | null, defaultBool = true): boolean {\n  if (value === 'true') return true;\n  if (value === 'false') return false;\n  return defaultBool;\n}\n\nfunction readFromLocalStorageUnsafe() {\n  appState.status = Number(localStorage.getItem('appStatus')) as AppStatus;\n  appState.sessionId = Number(localStorage.getItem('sessionId')) || SESSION_ID_DEFAULT;\n  appState.checkpoint = Number(localStorage.getItem('checkpoint')) || 0;\n  appState.pomodoroDuration =\n    Number(localStorage.getItem('pomodoroDefault')) || POMODORO_DURATION_DEFAULT;\n  appState.breakDuration = Number(localStorage.getItem('breakDefault')) || BREAK_DURATION_DEFAULT;\n  appState.countup = boolFromString(localStorage.getItem('countup'), COUNTUP_DEFAULT);\n  appState.speaker = localStorage.getItem('speaker') || SPEAKER_DEFAULT;\n}\n\nexport async function readFromLocalStorage() {\n  await navigator.locks.request('localStorage', async () => {\n    readFromLocalStorageUnsafe();\n  });\n}\n\nexport async function writeToLocalStorage() {\n  await navigator.locks.request('localStorage', async () => {\n    localStorage.setItem('appStatus', appState.status.toString());\n    localStorage.setItem('sessionId', appState.sessionId.toString());\n    localStorage.setItem('checkpoint', appState.checkpoint.toString());\n    localStorage.setItem('pomodoroDefault', appState.pomodoroDuration.toString());\n    localStorage.setItem('breakDefault', appState.breakDuration.toString());\n    localStorage.setItem('countup', appState.countup.toString());\n    localStorage.setItem('speaker', appState.speaker);\n  });\n}\n\nexport function isLeader() {\n  return appState.tabId === appState.leader;\n}\n", "import { generateKeyBetween } from './fridx';\nimport {\n  appState,\n  completedTasks,\n  readFromLocalStorage,\n  recurringTasks,\n  SESSION_ID_DEFAULT,\n  sessionTasks,\n  writeToLocalStorage,\n} from './state';\nimport { getSessionId, getTaskId, sessionSegmentStore, taskStore } from './storage';\nimport {\n  TASK_COMPLETED,\n  TASK_SESSION,\n  TASK_RECURRING,\n  Task,\n  TaskList,\n  TaskStatus,\n  APP_ACTIVE,\n  APP_BREAK,\n  APP_IDLE,\n} from './types';\n\nexport const callback = {\n  onChange: () => {\n    console.log('callback onChange');\n  },\n};\n\nconst channel = new BroadcastChannel('ease');\ntype MessageTypes = 'rollcallInit' | 'rollcallRespond' | 'goodbye' | 'updateTask' | 'sessionChange';\ntype MessageData = {\n  type: MessageTypes;\n  id: number;\n  tabId?: string;\n};\ntype Message = {\n  data: MessageData;\n  sender: string;\n};\n\n// Map of pending messages and their resolvers so that the sender can await a response\nfunction postMessage(data: MessageData) {\n  channel.postMessage({ data, sender: appState.tabId } as Message);\n}\n\n// All tabs update state from the storage on message\nchannel.addEventListener('message', async (e) => {\n  let { data, sender }: Message = e.data;\n  console.log('received message', data);\n  if (data.type === 'rollcallInit') {\n    appState.tabs = [appState.tabId, sender];\n    postMessage({ type: 'rollcallRespond', id: 0 });\n    callback.onChange();\n  }\n  if (data.type === 'rollcallRespond') {\n    appState.tabs.push(sender.toString());\n    callback.onChange();\n  }\n  if (data.type === 'goodbye') {\n    appState.tabs = appState.tabs.filter((tab) => tab !== sender);\n    appState.leader = data.tabId as string;\n    callback.onChange;\n  }\n  if (data.type === 'sessionChange') {\n    appState.leader = sender;\n    await readFromLocalStorage();\n    // Refresh active task\n    let activeTask = sessionTasks.list[0];\n    if (activeTask) {\n      activeTask = (await taskStore.get(activeTask.id)) as Task;\n      addTaskToLists(activeTask);\n    }\n    callback.onChange();\n  }\n  if (data.type === 'updateTask') {\n    appState.leader = sender;\n    removeTaskFromLists(data.id);\n    const task = await taskStore.get(data.id);\n    if (task !== null) addTaskToLists(task);\n    callback.onChange();\n  }\n});\n\nexport function rollcall() {\n  appState.tabs = [appState.tabId];\n  postMessage({ type: 'rollcallInit', id: 0 });\n  callback.onChange();\n}\n\nexport async function broadcastSessionChange() {\n  appState.leader = appState.tabId;\n  callback.onChange();\n  await writeToLocalStorage();\n  postMessage({ type: 'sessionChange', id: 0 });\n}\n\nexport async function flipCountDirection() {\n  appState.countup = !appState.countup;\n  await broadcastSessionChange();\n}\n\nexport async function setPomodoroDuration(duration: number) {\n  appState.checkpoint = Date.now();\n  appState.pomodoroDuration = duration;\n  await broadcastSessionChange();\n}\n\nexport async function setBreakDuration(duration: number) {\n  appState.leader = appState.tabId;\n  appState.checkpoint = Date.now();\n  appState.breakDuration = duration;\n  await broadcastSessionChange();\n}\n\nexport function getActiveTask() {\n  return sessionTasks.list[0];\n}\n\nasync function beginTimingTask(task: Task, time: number) {\n  task.checkpoint = time;\n  task.timeElapsed = task.timeElapsed || 0;\n  await taskStore.upsert(task);\n}\n\nasync function pauseTimingTask(task: Task, time: number) {\n  task.timeElapsed = (task.timeElapsed || 0) + time - (task.checkpoint || 0);\n  task.checkpoint = 0;\n  await taskStore.upsert(task);\n}\n\nasync function stopTimingTask(task: Task, time: number) {\n  let elapsed = (task.timeElapsed || 0) + time - (task.checkpoint || 0);\n  task.timeRemaining = Math.floor(Math.max(0, task.timeRemaining * 1000 - elapsed) / 1000);\n  task.timeElapsed = 0;\n  task.checkpoint = 0;\n  await taskStore.upsert(task);\n}\n\nexport async function startSession() {\n  let activeTask = getActiveTask();\n  if (!activeTask) return;\n\n  appState.status = APP_ACTIVE;\n  appState.sessionId = getSessionId();\n  appState.checkpoint = Date.now();\n\n  if (activeTask) {\n    await beginTimingTask(activeTask, appState.checkpoint);\n  }\n\n  await broadcastSessionChange();\n}\n\nexport async function breakSession() {\n  const now = Date.now();\n  const checkpoint = appState.checkpoint;\n  const status = appState.status;\n  appState.status = APP_BREAK;\n  appState.checkpoint = now;\n\n  let activeTask = getActiveTask();\n  if (activeTask) {\n    await pauseTimingTask(activeTask, now);\n  }\n\n  await broadcastSessionChange();\n  await sessionSegmentStore.add({\n    sessionId: appState.sessionId,\n    kind: status === APP_ACTIVE ? APP_ACTIVE : APP_BREAK,\n    start: checkpoint,\n    end: appState.checkpoint,\n  });\n}\nexport async function resumeSession() {\n  const checkpoint = appState.checkpoint;\n  appState.status = APP_ACTIVE;\n  appState.checkpoint = Date.now();\n\n  let activeTask = getActiveTask();\n  if (activeTask) {\n    await beginTimingTask(activeTask, appState.checkpoint);\n  }\n\n  await broadcastSessionChange();\n  await sessionSegmentStore.add({\n    sessionId: appState.sessionId,\n    kind: APP_BREAK,\n    start: checkpoint,\n    end: appState.checkpoint,\n  });\n}\nexport async function endSession() {\n  const now = Date.now();\n  const checkpoint = appState.checkpoint;\n  const sessionId = appState.sessionId;\n  appState.status = APP_IDLE;\n  appState.sessionId = SESSION_ID_DEFAULT;\n  appState.checkpoint = 0;\n\n  let activeTask = getActiveTask();\n  if (activeTask) {\n    await stopTimingTask(activeTask, now);\n  }\n\n  await broadcastSessionChange();\n  await sessionSegmentStore.add({\n    sessionId: sessionId,\n    kind: APP_ACTIVE,\n    start: checkpoint,\n    end: Date.now(),\n  });\n}\n\nwindow.addEventListener('beforeunload', async function (event) {\n  let tabs = appState.tabs;\n  postMessage({ type: 'goodbye', id: 0, tabId: tabs.filter((t) => t !== appState.tabId)[0] });\n  if (appState.status !== APP_IDLE && tabs.length === 1) {\n    console.log('Session is active.');\n    endSession();\n  }\n});\n\nasync function storeTask(config: Task) {\n  config.id = getTaskId();\n  if (!config.fridx) {\n    let lastTask;\n    if (config.status === TASK_SESSION) lastTask = sessionTasks.list[sessionTasks.list.length - 1];\n    if (config.status === TASK_RECURRING)\n      lastTask = recurringTasks.list[recurringTasks.list.length - 1];\n    if (config.status === TASK_COMPLETED)\n      lastTask = completedTasks.list[completedTasks.list.length - 1];\n    config.fridx = generateKeyBetween(lastTask?.fridx || null, null);\n  }\n  await taskStore.add(config);\n  return config;\n}\n\nfunction removeTaskFromLists(task: number | Task) {\n  if (typeof task === 'number') {\n    removeTaskFromList(task, sessionTasks);\n    removeTaskFromList(task, recurringTasks);\n    removeTaskFromList(task, completedTasks);\n  } else {\n    if (task.status === TASK_SESSION) removeTaskFromList(task.id, sessionTasks);\n    if (task.status === TASK_RECURRING) removeTaskFromList(task.id, recurringTasks);\n    if (task.status === TASK_COMPLETED) removeTaskFromList(task.id, completedTasks);\n  }\n}\n\nfunction addTaskToLists(task: Task) {\n  if (task.status === TASK_SESSION) addTaskToList(task, sessionTasks);\n  if (task.status === TASK_RECURRING) addTaskToList(task, recurringTasks);\n  if (task.status === TASK_COMPLETED) addTaskToList(task, completedTasks);\n}\n\nexport function idxFromTask(id: number, status: TaskStatus) {\n  let list: Task[] = [];\n  if (status === TASK_SESSION) list = sessionTasks.list;\n  if (status === TASK_RECURRING) list = recurringTasks.list;\n  if (status === TASK_COMPLETED) list = completedTasks.list;\n  return { idx: list.findIndex((t) => t.id === id), list };\n}\n\nexport async function idxFromId(id: number) {\n  const taskConfig = await taskStore.get(id);\n  if (taskConfig === null) return { idx: -1, list: [] };\n  return idxFromTask(id, taskConfig.status);\n}\n\nexport async function taskFromId(id: number): Promise<Task | null> {\n  let storeTask = await taskStore.get(id);\n  if (!storeTask) return null;\n  let task: Task | undefined;\n  if (storeTask?.status === TASK_SESSION) task = sessionTasks.list.find((t) => t.id === id);\n  if (storeTask?.status === TASK_RECURRING) task = recurringTasks.list.find((t) => t.id === id);\n  if (storeTask?.status === TASK_COMPLETED) task = completedTasks.list.find((t) => t.id === id);\n  Object.assign(task!, storeTask);\n  return task!;\n}\n\nfunction addTaskToList(task: Task, list: TaskList) {\n  list.list.push(task);\n  list.list.sort((a, b) => (a.fridx > b.fridx ? 1 : -1));\n  list.list = list.list;\n}\n\nfunction removeTaskFromList(taskId: number, list: TaskList) {\n  let found = false;\n  const newList = list.list.filter((t) => {\n    if (t.id !== taskId) return true;\n    found = true;\n  });\n  if (found) list.list = newList;\n}\n\nexport async function populateTasks() {\n  for await (const task of taskStore.iterate()) {\n    addTaskToLists(task);\n  }\n  callback.onChange();\n}\n\nexport async function createTask(taskConfig: Task) {\n  appState.leader = appState.tabId;\n  const task = await storeTask(taskConfig);\n  addTaskToLists(task);\n  callback.onChange();\n  postMessage({ type: 'updateTask', id: task.id });\n}\n\nexport async function deleteTask(task: Task) {\n  await updateTask(task, null);\n}\n\nexport async function updateTask(task: Task, update: Partial<Task> | null) {\n  appState.leader = appState.tabId;\n  let now = Date.now();\n  let activeTask = getActiveTask();\n  removeTaskFromLists(task);\n  let updatedTask = { ...task, ...update };\n\n  let taskDeleted = update === null;\n  let statusChanged =\n    taskDeleted || (update?.status !== undefined && task.status !== updatedTask.status);\n\n  if (taskDeleted) {\n    await taskStore.delete(task.id);\n  } else {\n    await taskStore.upsert(updatedTask);\n    addTaskToLists(updatedTask);\n  }\n\n  callback.onChange();\n  postMessage({ type: 'updateTask', id: task.id });\n\n  if (activeTask && activeTask.id === task.id && statusChanged) {\n    let nextActiveTask = getActiveTask();\n    if (nextActiveTask) {\n      await stopTimingTask(updatedTask, now);\n      await beginTimingTask(nextActiveTask, now);\n      callback.onChange();\n      postMessage({ type: 'updateTask', id: nextActiveTask.id });\n    } else {\n      await endSession();\n    }\n  }\n}\n", "// Modified version of:\n// https://github.com/luwes/little-vdom/blob/main/little-vdom.js\n\n// Adapted and fixed bugs from little-vdom.js\n// https://gist.github.com/developit/2038b141b31287faa663f410b6649a87\n// https://gist.github.com/marvinhagemeister/8950b1032d67918d21950b3985259d78\n// Added refs, style maps\n\ntype VNode = {\n  _type: string | Function;\n  _props: string | Record<string, any>;\n  _children: (string | number | false | null | undefined | VNode | VNode[])[];\n  key: string;\n  dom?: Node;\n  _patched?: VNode;\n  _state?: Record<string, any>;\n};\n\nexport type DNode = Node & { _vnode?: VNode; style?: any; data?: any };\n\nexport function h(type, props, ...children): VNode {\n  return {\n    _type: type,\n    _props: props, // An object for components and DOM nodes, a string for text nodes.\n    _children: children.filter((_) => !!_), // Filter out null and undefined children.\n    key: props && (props.key || props.id),\n  };\n}\n\nexport function Fragment(props) {\n  return props.children;\n}\n\nexport function render(\n  newVNode: VNode,\n  dom: DNode,\n  oldVNode = dom._vnode || (dom._vnode = {} as VNode),\n) {\n  return diff(h(Fragment, {}, newVNode), dom, oldVNode);\n}\n\nexport function diff(newVNode: VNode, dom: DNode, oldVNode: VNode, currentChildIndex = -1) {\n  if (Array.isArray(newVNode)) {\n    return diffChildren(dom, newVNode, oldVNode);\n  }\n\n  // Check if we have a component. Only functions have a .call() method.\n  // Here components have a different signature compared to Preact or React:\n  //\n  // (props, state, updateFn) => VNode;\n  //\n  // The 3rd argument is basically similar concept-wise to setState\n  else if (typeof newVNode._type === 'function') {\n    // Initialize state of component if necessary\n    newVNode._state = oldVNode._state || {};\n    // Add children to props\n    const props = { children: newVNode._children, ...(newVNode._props as Record<string, any>) };\n    const renderResult = newVNode._type(\n      props,\n      newVNode._state,\n      // Updater function that is passed as 3rd argument to components\n      (nextState) => {\n        // Update state with new value\n        Object.assign(newVNode._state!, nextState);\n        return diff(newVNode, dom, newVNode);\n      },\n    );\n\n    newVNode._patched = diff(\n      renderResult,\n      dom,\n      (oldVNode && oldVNode._patched) || ({} as VNode),\n      currentChildIndex,\n    );\n    // newVNode.dom = dom;\n\n    return (dom._vnode = newVNode);\n  }\n\n  // Standard DOM elements\n  else {\n    // Create a DOM element and assign it to the vnode. If one already exists,\n    // we will reuse the existing one and not create a new node.\n    const newDom: DNode =\n      oldVNode.dom ||\n      (newVNode._type\n        ? document.createElement(newVNode._type)\n        : // If we have a text node, vnode.props will be a string\n          new Text(newVNode._props as string));\n\n    // diff props\n    if (newVNode._props != oldVNode._props) {\n      // If newVNode.type is truthy (=not an empty string) we have a DOM node\n      if (newVNode._type) {\n        const { key, ref, ...newProps } = newVNode._props as Record<string, any>;\n        if (ref) ref.current = newDom;\n\n        for (let name in newProps) {\n          const value = newProps[name];\n          // A string object has a trim method.\n          if (name === 'style' && !value.trim) {\n            for (const n in value) {\n              newDom.style[n] = value[n];\n            }\n          } else if (value != (oldVNode._props && oldVNode._props[name])) {\n            if (name in newDom || (name = name.toLowerCase()) in newDom) {\n              newDom[name] = value;\n            } else if (value != null) {\n              (newDom as Element).setAttribute(name, value);\n            } else {\n              (newDom as Element).removeAttribute(name);\n            }\n          }\n        }\n      }\n\n      // Otherwise a text node\n      else {\n        // Update text node content\n        newDom.data = newVNode._props;\n      }\n    }\n\n    // diff children (typed/keyed)\n    diffChildren(newDom, newVNode._children, oldVNode);\n\n    // insert at position\n    if (!oldVNode.dom || currentChildIndex > -1) {\n      dom.insertBefore((newVNode.dom = newDom), dom.childNodes[currentChildIndex + 1] || null);\n    }\n\n    return (dom._vnode = Object.assign(oldVNode, newVNode));\n  }\n}\n\nfunction diffChildren(parentDom, newChildren, oldVNode) {\n  const oldChildren = oldVNode._normalizedChildren || [];\n  oldVNode._normalizedChildren = newChildren.concat.apply([], newChildren).map((child, index) => {\n    // If the vnode has no children we assume that we have a string and\n    // convert it into a text vnode.\n    const nextNewChild = child._children ? child : h('', '' + child);\n\n    // If we have previous children we search for one that matches our\n    // current vnode.\n    const nextOldChild =\n      oldChildren.find((oldChild, childIndex) => {\n        let result =\n          oldChild &&\n          oldChild._type == nextNewChild._type &&\n          oldChild.key == nextNewChild.key &&\n          (childIndex == index && (index = undefined), (oldChildren[childIndex] = 0), oldChild);\n        // if (result) console.log('found vnode', result);\n        return result;\n      }) || {};\n\n    // Continue diffing recursively against the next child.\n    return diff(nextNewChild, parentDom, nextOldChild, index);\n  });\n\n  // remove old children if there are any\n  oldChildren.forEach(removePatchedChildren);\n\n  return oldVNode;\n}\n\nfunction removePatchedChildren(child) {\n  const { _children = [], _patched } = child;\n  // remove children\n  if (child.dom) {\n    child.dom.remove();\n  } else {\n    _children.forEach((c) => c && removePatchedChildren(c));\n    _patched && removePatchedChildren(_patched);\n  }\n}\n\nconst tags = ['div', 'h1', 'button', 'p', 'input', 'span', 'progress'] as const;\nexport const dom = tags.reduce((acc, tag) => {\n  acc[tag] = (props, ...children) => h(tag, props, ...children);\n  return acc;\n}, {}) as unknown as Record<\n  (typeof tags)[number],\n  (props: Record<string, any>, ...children: VNode['_children']) => VNode\n>;\n", "import { generateKeyBetween } from './fridx';\nimport { audioStore, setupStore } from './storage';\nimport {\n  uploadAudioFiles,\n  playShuffledAudio,\n  ProcessOptions,\n  storeAudio,\n  processAudioFile,\n} from './music';\nimport {\n  createTask,\n  deleteTask,\n  updateTask,\n  populateTasks,\n  idxFromTask,\n  taskFromId,\n  callback,\n  startSession,\n  endSession,\n  breakSession,\n  rollcall,\n  flipCountDirection,\n  resumeSession,\n  setPomodoroDuration,\n  setBreakDuration,\n  getActiveTask,\n} from './events';\nimport { render, diff, h, dom, DNode } from './vdom';\nimport {\n  TASK_SESSION,\n  TASK_RECURRING,\n  TaskStatus,\n  TASK_COMPLETED,\n  Task,\n  TaskList,\n  AppState,\n  APP_IDLE,\n  APP_ACTIVE,\n  APP_BREAK,\n} from './types';\nimport { appState, isLeader } from './state';\nimport { playSpeech, stopMusic } from './audioPlayer';\nconst { div, h1, button, p, input, span } = dom;\n\nconst DEFAULT_TASK_TIME = 25 * 60;\n\nsetupStore().then(() => {\n  populateTasks();\n});\n\nrollcall();\n\nasync function handleAudioUpload(files: File[]) {\n  const options: ProcessOptions = {\n    normalize: true,\n    fadeIn: 0.01,\n    fadeOut: 0.01,\n  };\n  try {\n    appState.audioUploadState = 0;\n    redraw();\n    let portion = 1 / files.length;\n    for (const file of files) {\n      const processedAudio = await processAudioFile(file, options);\n      await storeAudio(processedAudio);\n      appState.audioUploadState += portion;\n      redraw();\n    }\n    appState.audioUploadState = 1.01;\n    redraw();\n  } catch (e) {\n    console.error(e);\n  }\n  await new Promise((resolve) => setTimeout(resolve, 400));\n  appState.audioUploadState = 1;\n  redraw();\n}\n\n// START NAVIGATION\n////////////////////////////////////////////////////////////////////////////////\n\ntype Coords = { x: number; y: number };\n\nfunction centerFromRect(rect: DOMRect): Coords {\n  return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };\n}\n\nenum Axis {\n  X,\n  Y,\n  None,\n}\n\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n  None,\n}\n\nfunction axisFromDirection(dir: Direction) {\n  if (dir === Direction.Up || dir === Direction.Down) return Axis.Y;\n  if (dir === Direction.Left || dir === Direction.Right) return Axis.X;\n  return Axis.None;\n}\n\nfunction secondaryAxisFromDirection(dir: Direction) {\n  if (dir === Direction.Up || dir === Direction.Down) return Axis.X;\n  if (dir === Direction.Left || dir === Direction.Right) return Axis.Y;\n  return Axis.None;\n}\n\n// NAV STATE\nlet lastRect: DOMRect | null = null;\nlet lastAxis: Axis = Axis.None;\nlet lastTargetCoords: Coords = { x: Infinity, y: Infinity };\nlet lastDirection: Direction = Direction.None;\n\nfunction resetNavState() {\n  lastTargetCoords = { x: Infinity, y: Infinity };\n  lastDirection = Direction.None;\n  lastAxis = Axis.None;\n}\n\nfunction groupElementsByRow(getElementCandidates: () => Element[]) {\n  const elements: Element[] = getElementCandidates();\n  if (elements.length === 0) return [];\n\n  // Sort elements by their top position\n  elements.sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top);\n\n  let rows: Element[][] = [];\n\n  elements.forEach((element) => {\n    let rect = element.getBoundingClientRect();\n    let added = false;\n\n    // Try to place the element in an existing row\n    for (let row of rows) {\n      let firstInRow = row[0].getBoundingClientRect();\n      let overlapHeight =\n        Math.min(rect.bottom, firstInRow.bottom) - Math.max(rect.top, firstInRow.top);\n      let elementHeight = rect.bottom - rect.top;\n      let rowHeight = firstInRow.bottom - firstInRow.top;\n\n      if (overlapHeight / elementHeight > 0.5 || overlapHeight / rowHeight > 0.5) {\n        row.push(element);\n        added = true;\n        break;\n      }\n    }\n\n    // If not added, create a new row\n    if (!added) {\n      rows.push([element]);\n    }\n  });\n\n  // Sort each row from left to right\n  rows.forEach((row) =>\n    row.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left),\n  );\n\n  return rows;\n}\n\nfunction groupElementsByColumn(getElementCandidates: () => Element[]) {\n  const elements: Element[] = getElementCandidates();\n  if (elements.length === 0) return [];\n\n  // Sort elements by their left position\n  elements.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);\n\n  let columns: Element[][] = [];\n\n  elements.forEach((element) => {\n    let rect = element.getBoundingClientRect();\n    let added = false;\n\n    // Try to place the element in an existing column\n    for (let column of columns) {\n      let firstInColumn = column[0].getBoundingClientRect();\n      let overlapWidth =\n        Math.min(rect.right, firstInColumn.right) - Math.max(rect.left, firstInColumn.left);\n      let elementWidth = rect.right - rect.left;\n      let columnWidth = firstInColumn.right - firstInColumn.left;\n\n      if (overlapWidth / elementWidth > 0.5 || overlapWidth / columnWidth > 0.5) {\n        column.push(element);\n        added = true;\n        break;\n      }\n    }\n\n    // If not added, create a new column\n    if (!added) {\n      columns.push([element]);\n    }\n  });\n\n  // Sort each column from top to bottom\n  columns.forEach((column) =>\n    column.sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top),\n  );\n\n  return columns;\n}\n\nfunction getNavigableElements(container = document) {\n  return Array.from(container.querySelectorAll('input:not(.skip-navigation), .navigable')).filter(\n    (el) => !el.hasAttribute('disabled'),\n  );\n}\n\nfunction getNextNonOverlappingRowOrColumn(\n  getElementCandidates: () => Element[],\n  coords: Coords,\n  direction: Direction,\n) {\n  const { x, y } = coords;\n  const rows = groupElementsByRow(getElementCandidates);\n  const columns = groupElementsByColumn(getElementCandidates);\n\n  if (direction === Direction.Down || direction === Direction.Up) {\n    let selectedRow = rows.find((row) =>\n      row.some((el) => {\n        let rect = el.getBoundingClientRect();\n        return rect.top <= y && rect.bottom >= y;\n      }),\n    );\n\n    if (direction === Direction.Down && selectedRow) {\n      let index = rows.indexOf(selectedRow);\n      return index + 1 < rows.length ? rows[index + 1] : null;\n    } else if (direction === Direction.Up && selectedRow) {\n      let index = rows.indexOf(selectedRow);\n      return index - 1 >= 0 ? rows[index - 1] : null;\n    }\n  } else {\n    let selectedColumn = columns.find((column) =>\n      column.some((el) => {\n        let rect = el.getBoundingClientRect();\n        return rect.left <= x && rect.right >= x;\n      }),\n    );\n\n    if (direction === Direction.Right && selectedColumn) {\n      let index = columns.indexOf(selectedColumn);\n      return index + 1 < columns.length ? columns[index + 1] : null;\n    } else if (direction === Direction.Left && selectedColumn) {\n      let index = columns.indexOf(selectedColumn);\n      return index - 1 >= 0 ? columns[index - 1] : null;\n    }\n  }\n\n  return null;\n}\n\nfunction findClosestElementInRowOrColumn(coords: Coords, axis: Axis, group: Element[]) {\n  if (!group || group.length === 0) return null;\n\n  let closest: Node = document;\n  let distance = Infinity;\n\n  for (const el of group) {\n    let rect = el.getBoundingClientRect();\n    let dist =\n      axis === Axis.X\n        ? Math.abs(rect.left + rect.width / 2 - coords.x)\n        : Math.abs(rect.top + rect.height / 2 - coords.y);\n\n    if (dist < distance) {\n      distance = dist;\n      closest = el;\n    }\n  }\n\n  if (closest === document) return null;\n  return closest;\n}\n\nfunction updateNavigationState(targetCoords: { x: number; y: number }, dir: Direction) {\n  let target = { ...targetCoords };\n  let newAxis = axisFromDirection(dir);\n  if (newAxis === Axis.None) {\n    lastAxis = Axis.None;\n    lastDirection = Direction.None;\n    lastTargetCoords = { x: Infinity, y: Infinity };\n  } else if (newAxis === lastAxis) {\n    // Maintain a goal column/row when continuing in the same axis\n    if (newAxis === Axis.X) {\n      if (lastTargetCoords.y !== Infinity) target.y = lastTargetCoords.y;\n      lastTargetCoords = target;\n    } else if (newAxis === Axis.Y) {\n      if (lastTargetCoords.x !== Infinity) target.x = lastTargetCoords.x;\n      lastTargetCoords = target;\n    } else {\n      lastTargetCoords = { x: Infinity, y: Infinity };\n    }\n  } else {\n    lastTargetCoords = target;\n  }\n  lastAxis = newAxis;\n  lastDirection = dir;\n  return target;\n}\n\nfunction getNearestEl(\n  getNavigableElements: () => Element[],\n  targetCoords: { x: number; y: number },\n  dir: Direction,\n) {\n  // If we don't have a direction, find the nearest element even if it overlaps\n  // the targetCoords.\n  if (dir === Direction.None) {\n    let elements = getNavigableElements();\n    let closest: Node = document;\n    let distance = Infinity;\n    for (const el of elements) {\n      let rect = el.getBoundingClientRect();\n      let dist = Math.hypot(\n        targetCoords.x - (rect.left + rect.width / 2),\n        targetCoords.y - (rect.top + rect.height / 2),\n      );\n      if (dist < distance) {\n        distance = dist;\n        closest = el;\n      }\n    }\n    if (closest === document) return null;\n    return closest;\n  }\n  {\n    // If we are going Left or Right, default to something like a ray cast.\n    // If we don't find anything, we will fall back to the row/column method.\n    if (dir === Direction.Left) {\n      let elements = getNavigableElements();\n      let closest: Node = document;\n      let distance = Infinity;\n      for (const el of elements) {\n        let rect = el.getBoundingClientRect();\n        if (rect.right > targetCoords.x) continue;\n        if (rect.top > targetCoords.y || rect.bottom < targetCoords.y) continue;\n        let dist = targetCoords.x - rect.right;\n        if (dist < distance) {\n          distance = dist;\n          closest = el;\n        }\n      }\n      if (closest !== document) return closest;\n    } else if (dir === Direction.Right) {\n      let elements = getNavigableElements();\n      let closest: Node = document;\n      let distance = Infinity;\n      for (const el of elements) {\n        let rect = el.getBoundingClientRect();\n        if (rect.left < targetCoords.x) continue;\n        if (rect.top > targetCoords.y || rect.bottom < targetCoords.y) continue;\n        let dist = rect.left - targetCoords.x;\n        if (dist < distance) {\n          distance = dist;\n          closest = el;\n        }\n      }\n      if (closest !== document) return closest;\n    }\n  }\n  // Fallback based on rows and columns\n  let rowOrColumn = getNextNonOverlappingRowOrColumn(getNavigableElements, targetCoords, dir);\n  if (!rowOrColumn) return null;\n  let closest = findClosestElementInRowOrColumn(\n    targetCoords,\n    secondaryAxisFromDirection(dir),\n    rowOrColumn,\n  );\n  return closest;\n}\n\nfunction navigateEl(el: Element, dir: Direction) {\n  let elBox = el.getBoundingClientRect();\n  let targetCoords = centerFromRect(elBox);\n  targetCoords = updateNavigationState(targetCoords, dir);\n  let closest = getNearestEl(getNavigableElements, targetCoords, dir);\n  if (closest && closest instanceof Element) (closest as any).focus();\n}\n\n{\n  let container = document;\n  container.addEventListener('focusin', (event) => {\n    if (event.target instanceof Element) lastRect = event.target.getBoundingClientRect();\n  });\n  container.addEventListener('focusout', () => {\n    setTimeout(() => {\n      if (!container.contains(document.activeElement) || document.activeElement === document.body) {\n        resetNavState();\n        if (lastRect) {\n          let targetCoords = centerFromRect(lastRect);\n          targetCoords = updateNavigationState(targetCoords, Direction.None);\n          let closest = getNearestEl(getNavigableElements, targetCoords, Direction.None);\n          if (closest && closest instanceof Element) (closest as any).focus();\n        }\n      }\n    }, 0);\n  });\n  container.addEventListener('keydown', (e) => {\n    if (e.key === 'Tab') {\n      resetNavState();\n    }\n  });\n  container.addEventListener('mousedown', (e) => {\n    resetNavState();\n  });\n  window.addEventListener('dragenter', (e) => {\n    e.preventDefault();\n  });\n  window.addEventListener('dragover', (e) => {\n    e.preventDefault();\n    if (isFileDrag(e) && !appState.draggingFile) {\n      appState.draggingFile = true;\n      redraw();\n    }\n  });\n  function endDragFile() {\n    if (appState.draggingFile) {\n      appState.draggingFile = false;\n      redraw();\n    }\n  }\n  window.addEventListener('drop', (e) => {\n    e.preventDefault();\n    endDragFile();\n  });\n  window.addEventListener('dragend', (e) => {\n    e.preventDefault();\n    endDragFile();\n  });\n  window.addEventListener('dragleave', (e) => {\n    // Detect when the drag leaves the window\n    if (\n      e.clientX <= 0 ||\n      e.clientY <= 0 ||\n      e.clientX >= window.innerWidth ||\n      e.clientY >= window.innerHeight\n    ) {\n      e.preventDefault();\n      endDragFile();\n    }\n  });\n}\n\n// END NAVIGATION\n////////////////////////////////////////////////////////////////////////////////\n\n// Keys\nconst SPACE = ' ';\nconst ENTER = 'Enter';\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\n\nlet styles = {\n  task: {\n    borderTop: '2px solid transparent',\n    borderBottom: '2px solid transparent',\n    transition: 'all 0.2s ease',\n  },\n  taskDropTop: {\n    borderTop: '2px solid var(--accent)',\n  },\n  taskDropBottom: {\n    borderBottom: '2px solid var(--accent)',\n  },\n};\n\n/**\n * 1h 30m => 90 * 60\n * 2H => 2 * 60 * 60\n * 25m => 25 * 60\n * 30 => 30 * 60\n */\nfunction parseHumanReadableTime(hrTime: string): number {\n  try {\n    let timeStr = hrTime.trim().toLowerCase();\n    let time = 0;\n    let includesHours = timeStr.includes('h');\n    let includesMinutes = timeStr.includes('m');\n    let includesSeconds = timeStr.includes('s');\n    if (includesHours) {\n      const hours = parseInt(timeStr.split('h', 2)[0]);\n      if (hours) time += hours * 60 * 60;\n      timeStr = timeStr.split('h', 2)[1];\n    }\n    if (includesMinutes) {\n      const minutes = parseInt(timeStr.split('m', 2)[0]);\n      if (minutes) time += minutes * 60;\n    }\n    if (includesSeconds) {\n      const seconds = parseInt(timeStr.split('s', 2)[0]);\n      if (seconds) time += seconds;\n    }\n    if (!includesHours && !includesMinutes && !includesSeconds) {\n      time = parseInt(timeStr) * 60;\n    }\n    return time;\n  } catch (e) {\n    return DEFAULT_TASK_TIME;\n  }\n}\n\ntype PartitionedTime = {\n  hours: number;\n  minutes: number;\n  seconds: number;\n};\n\nfunction partitionTime(time: number): PartitionedTime {\n  const hours = Math.floor(time / 3600);\n  const minutes = Math.floor((time % 3600) / 60);\n  const seconds = Math.floor(time % 60);\n  return { hours, minutes, seconds };\n}\n\ntype FormatTimeOptions = {\n  forceHours?: boolean;\n  forceMinutes?: boolean;\n  forceSeconds?: boolean;\n  pad?: number;\n};\n\nfunction formatTime(time: PartitionedTime, opts: FormatTimeOptions = {}): string {\n  const { hours, minutes, seconds } = time;\n  const { pad = 1 } = opts;\n  let res = '';\n  if (hours > 0 || opts.forceHours) res += `${hours}h`.padStart(pad + 1, '0');\n  if (minutes > 0 || opts.forceMinutes) {\n    if (res !== '') res += ' ';\n    res += `${minutes}m`.padStart(pad + 1, '0');\n  }\n  if (seconds > 0 || opts.forceSeconds) {\n    if (res !== '') res += ' ';\n    res += `${seconds}s`.padStart(pad + 1, '0');\n  }\n  if (res === '') res = '0m'.padStart(pad + 1, '0');\n  return res;\n}\n\nfunction formatTimestamp(timestamp: number, opts: FormatTimeOptions = {}): string {\n  return formatTime(partitionTime(timestamp), opts);\n}\n\nenum DragState {\n  None,\n  Top,\n  Bottom,\n}\n\nfunction isFileDrag(e: DragEvent) {\n  if (e.dataTransfer?.items) {\n    for (let i = 0; i < e.dataTransfer.items.length; i++) {\n      if (e.dataTransfer.items[i].kind === 'file') return true;\n    }\n  } else {\n    // Fallback for older browsers\n    if ((e.dataTransfer?.files.length || 0) > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// HANDLERS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction onCreateTask(status: TaskStatus, description: string) {\n  if (!description) return;\n  const time = Date.now();\n  createTask({\n    id: 0,\n    description,\n    status,\n    timeEstimate: DEFAULT_TASK_TIME,\n    timeRemaining: DEFAULT_TASK_TIME,\n    timeElapsed: 0,\n    checkpoint: 0,\n    createdAt: time,\n    completedAt: 0,\n    fridx: '',\n  });\n}\n\nconst audioDropHandlers = {\n  ondragover: (e) => {\n    // Prevent default to allow drop\n    e.preventDefault();\n    e.dataTransfer!.dropEffect = 'copy';\n  },\n  ondragenter: (e) => {\n    e.preventDefault();\n  },\n  ondrop: (e: DragEvent) => {\n    e.dataTransfer!.dropEffect = 'copy';\n    e.preventDefault();\n    uploadAudioFiles((files) => handleAudioUpload(files))(e);\n  },\n};\n\nfunction basicKeydownNavigationHandler(e: KeyboardEvent) {\n  if (e.key === ARROW_UP) navigateEl(e.target as Element, Direction.Up);\n  if (e.key === ARROW_DOWN) navigateEl(e.target as Element, Direction.Down);\n  if (e.key === ARROW_LEFT) navigateEl(e.target as Element, Direction.Left);\n  if (e.key === ARROW_RIGHT) navigateEl(e.target as Element, Direction.Right);\n}\n\nfunction sessionTaskFromRecurringTask(recurringTask: Task) {\n  let description = recurringTask.description;\n  if (!description) return;\n  const time = Date.now();\n  createTask({\n    id: 0,\n    description,\n    status: TASK_SESSION,\n    timeEstimate: recurringTask.timeEstimate,\n    timeRemaining: recurringTask.timeEstimate,\n    timeElapsed: 0,\n    checkpoint: 0,\n    createdAt: time,\n    completedAt: 0,\n    fridx: '',\n  });\n}\n\n// VIEWS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction sectionHeaderView({ title, collapsed, oncollapse, onexpand }) {\n  return div(\n    {},\n    button(\n      {\n        class: 'collapse-button navigable',\n        onclick: () => {\n          if (collapsed) {\n            onexpand();\n          } else {\n            oncollapse();\n          }\n        },\n        onkeydown: (e) => {\n          if (e.key === ARROW_LEFT) oncollapse();\n          if (e.key === ARROW_RIGHT) onexpand();\n          if (e.key === ARROW_UP) navigateEl(e.target, Direction.Up);\n          if (e.key === ARROW_DOWN) navigateEl(e.target, Direction.Down);\n        },\n      },\n      div({ class: 'collapse-icon' }, collapsed ? '\u25B8' : '\u25BE'),\n      h1({ class: 'section-header' }, title),\n    ),\n  );\n}\n\nfunction taskView(\n  { task, active = false }: { task: Task; active: boolean },\n  { renderSignal = 0, dragState = DragState.None },\n  update,\n) {\n  function updateTimeEstimate(e) {\n    let time = parseHumanReadableTime(e.target.value);\n    updateTask(task, { timeEstimate: time, timeRemaining: time });\n  }\n  const domId = `task-${task.id}`;\n\n  let resolvedStyles = styles.task;\n  if (dragState === DragState.Bottom) resolvedStyles = { ...styles.task, ...styles.taskDropBottom };\n  if (dragState === DragState.Top) resolvedStyles = { ...styles.task, ...styles.taskDropTop };\n\n  // get human-readable createdAt from task\n  let createdAt = new Date(task.createdAt).toLocaleString();\n  // get number of days since task was created\n  let daysAgo = Math.floor((Date.now() - task.createdAt) / (1000 * 60 * 60 * 24));\n  let daysAgoLabel = daysAgo === 0 ? 'Today' : `${daysAgo} days ago`;\n\n  let timeElapsedLabel = '';\n  if (active) {\n    let elapsed = task.timeElapsed || 0;\n    if (task.checkpoint) {\n      let now = Date.now();\n      elapsed += now - task.checkpoint;\n    }\n    let elapsedSeconds = Math.floor(elapsed / 1000);\n    timeElapsedLabel = formatTime(partitionTime(elapsedSeconds), {\n      forceMinutes: true,\n      forceSeconds: true,\n      pad: 2,\n    });\n    timeElapsedLabel += ' / ';\n    setTimeout(() => {\n      if (appState.status !== APP_ACTIVE) return;\n      if (task.id !== getActiveTask()?.id) return;\n      update({ renderSignal: renderSignal + 1 });\n    }, 400);\n  }\n\n  return div(\n    {\n      id: domId,\n      className: 'task',\n      style: resolvedStyles,\n      title: `\n${daysAgoLabel} - ${createdAt}\n`,\n      draggable: true,\n      ondragover: (e) => {\n        e.preventDefault();\n        e.dataTransfer.dropEffect = 'move';\n        const taskDiv = document.getElementById(domId) as HTMLElement;\n        // find whether the mouse is closer to the top or bottom of the element\n        const rect = taskDiv.getBoundingClientRect();\n        const y = e.clientY - rect.top;\n        if (y > rect.height / 2) {\n          update({ dragState: DragState.Bottom });\n        } else {\n          update({ dragState: DragState.Top });\n        }\n      },\n      ondrop: async (e) => {\n        e.preventDefault();\n        try {\n          if (isFileDrag(e)) return;\n          const taskId = parseInt(e.dataTransfer.getData('text/plain'));\n          const taskDiv = document.getElementById(domId) as HTMLElement;\n          const rect = taskDiv.getBoundingClientRect();\n          const y = e.clientY - rect.top;\n          let { idx, list } = idxFromTask(task.id, task.status);\n          let newFridx = '';\n          if (y > rect.height / 2) {\n            // drop below\n            let otherTask = list[idx + 1];\n            let nextTaskFridx = otherTask?.fridx || null;\n            newFridx = generateKeyBetween(task.fridx, nextTaskFridx);\n          } else {\n            // drop above\n            let prevTask = list[idx - 1];\n            let prevTaskFridx = prevTask?.fridx || null;\n            newFridx = generateKeyBetween(prevTaskFridx, task.fridx);\n          }\n          let droppedTask = await taskFromId(taskId);\n          await updateTask(droppedTask!, { fridx: newFridx, status: task.status });\n        } catch (e) {\n          console.error(e);\n        } finally {\n          update({ dragState: DragState.None });\n        }\n      },\n      ondragleave: (e) => {\n        e.preventDefault();\n        update({ dragState: DragState.None });\n      },\n      ondragstart: (e) => {\n        e.dataTransfer.setData('text/plain', task.id.toString());\n        e.dataTransfer.effectAllowed = 'move';\n      },\n    },\n    span({ class: 'drag-handle' }, '\u283F'),\n    input({\n      class: 'description-input',\n      value: task.description,\n      oninput: (e) => {\n        updateTask(task, { description: e.target.value });\n      },\n      onkeydown: (e) => {\n        if (e.key === ARROW_UP) navigateEl(e.target, Direction.Up);\n        if (e.key === ARROW_DOWN) navigateEl(e.target, Direction.Down);\n        if (e.key === ARROW_RIGHT && e.target.selectionStart === e.target.value.length) {\n          navigateEl(e.target, Direction.Right);\n        }\n      },\n    }),\n    div(\n      {},\n      ...(active ? [span({}, timeElapsedLabel)] : []),\n      ...(task.status === TASK_COMPLETED\n        ? []\n        : [\n            input({\n              class: 'time-input',\n              value: formatTimestamp(task.timeRemaining),\n              onblur: (e) => {\n                updateTimeEstimate(e);\n              },\n              onkeydown: (e) => {\n                if (e.key === ENTER) updateTimeEstimate(e);\n                if (e.key === ARROW_UP) navigateEl(e.target, Direction.Up);\n                if (e.key === ARROW_DOWN) navigateEl(e.target, Direction.Down);\n                if (e.key === ARROW_LEFT && e.target.selectionStart === 0) {\n                  navigateEl(e.target, Direction.Left);\n                }\n                if (e.key === ARROW_RIGHT && e.target.selectionStart === e.target.value.length) {\n                  navigateEl(e.target, Direction.Right);\n                }\n              },\n            }),\n          ]),\n    ),\n    div(\n      {},\n      active &&\n        button(\n          {\n            class: 'navigable',\n            onkeydown: (e) => {\n              if (e.key === SPACE || e.key === ENTER) {\n                e.preventDefault();\n                updateTask(task, { status: TASK_COMPLETED });\n              } else basicKeydownNavigationHandler(e);\n            },\n            onclick: () => updateTask(task, { status: TASK_COMPLETED }),\n          },\n          '\u2713',\n        ),\n      task.status === TASK_RECURRING &&\n        button(\n          {\n            class: 'navigable',\n            onkeydown: (e) => {\n              if (e.key === SPACE || e.key === ENTER) {\n                e.preventDefault();\n                sessionTaskFromRecurringTask(task);\n              } else basicKeydownNavigationHandler(e);\n            },\n            onclick: () => {\n              sessionTaskFromRecurringTask(task);\n            },\n          },\n          '+',\n        ),\n      !active &&\n        button(\n          {\n            class: 'delete-button navigable',\n            onkeydown: (e) => {\n              if (e.key === SPACE || e.key === ENTER) {\n                e.preventDefault();\n                deleteTask(task);\n              } else basicKeydownNavigationHandler(e);\n            },\n            onclick: () => deleteTask(task),\n          },\n          '\u2715',\n        ),\n    ),\n  );\n}\n\nfunction activeTaskView({ activeTask }: { activeTask: Task | null }) {\n  if (!activeTask) {\n    return div({ className: 'active-task' }, h1({}, 'No Active Task'));\n  }\n  return div(\n    { className: 'active-task' },\n    h1({}, 'Active Task'),\n    h(taskView, { task: activeTask, key: activeTask.id, active: true }),\n  );\n}\n\nfunction taskListView(tasks: TaskList) {\n  const taskListDiv = div(\n    { className: 'task-list' },\n    ...tasks.list.map((task) => h(taskView, { task, key: task.id })),\n  );\n  return taskListDiv;\n}\n\nfunction newTaskInputView({ status }: { status: TaskStatus }) {\n  const inputId = Math.random().toString();\n  function createNewTaskFromInput() {\n    let inputEl = document.getElementById(inputId) as HTMLInputElement;\n    let value = inputEl.value;\n    if (!value) return;\n    onCreateTask(status, value);\n    inputEl.value = '';\n  }\n\n  return div(\n    { class: 'new-task' },\n    input({\n      id: inputId,\n      type: 'text',\n      placeholder: 'Add a task',\n      onkeydown: (e) => {\n        if (e.key === ENTER) {\n          onCreateTask(status, e.target.value);\n          e.target.value = '';\n        }\n        if (e.key === ARROW_UP) navigateEl(e.target, Direction.Up);\n        if (e.key === ARROW_DOWN) navigateEl(e.target, Direction.Down);\n        if (e.key === ARROW_RIGHT) navigateEl(e.target, Direction.Right);\n      },\n    }),\n    div(\n      { style: { display: 'flex' } },\n      button(\n        {\n          class: 'square-button navigable',\n          onclick: (e) => {\n            createNewTaskFromInput();\n          },\n          onkeydown: (e) => {\n            if (e.key === SPACE || e.key === ENTER) {\n              e.preventDefault();\n              createNewTaskFromInput();\n            } else {\n              basicKeydownNavigationHandler(e);\n            }\n          },\n        },\n        '+',\n      ),\n    ),\n  );\n}\n\nfunction sessionTasksView({ sessionTasks }: AppState, { collapsed = false }, update) {\n  return div(\n    { className: 'session-tasks' },\n    sectionHeaderView({\n      title: 'Session Tasks',\n      collapsed,\n      oncollapse: () => update({ collapsed: true }),\n      onexpand: () => update({ collapsed: false }),\n    }),\n    collapsed\n      ? null\n      : [h(taskListView, sessionTasks), h(newTaskInputView, { status: TASK_SESSION })],\n  );\n}\n\nfunction recurringTasksView({ recurringTasks }: AppState, { collapsed = false }, update) {\n  return div(\n    { className: 'recurring-tasks' },\n    sectionHeaderView({\n      title: 'Recurring Tasks',\n      collapsed,\n      oncollapse: () => update({ collapsed: true }),\n      onexpand: () => update({ collapsed: false }),\n    }),\n    collapsed\n      ? null\n      : [h(taskListView, recurringTasks), h(newTaskInputView, { status: TASK_RECURRING })],\n  );\n}\n\nfunction completedTasksView({ completedTasks }: AppState, { collapsed = true }, update) {\n  return div(\n    { className: 'completed-tasks' },\n    sectionHeaderView({\n      title: 'Completed Tasks',\n      collapsed,\n      oncollapse: () => update({ collapsed: true }),\n      onexpand: () => update({ collapsed: false }),\n    }),\n    collapsed ? null : h(taskListView, completedTasks),\n  );\n}\n\nfunction sessionButtonView({ onclick, label }: { onclick: () => void; label: string }) {\n  return button(\n    {\n      class: 'session-button navigable',\n      onclick,\n      onkeydown: basicKeydownNavigationHandler,\n    },\n    label,\n  );\n}\n\nfunction pomodoroTimerView(\n  { checkpoint, countup, pomodoroDuration, breakDuration, status, speaker }: AppState,\n  { renderSignal = 0, prevTimeRemaining = 0, editing = false, editingValue = '' },\n  update,\n) {\n  function updateTimerFromInput(e) {\n    let time = parseHumanReadableTime(e.target.value);\n    update({ editing: false, editingValue: '' });\n    if (status === APP_ACTIVE) {\n      setPomodoroDuration(time);\n    } else if (status === APP_BREAK) {\n      setBreakDuration(time);\n    }\n  }\n\n  let now = Date.now();\n  let negative = false;\n  let duration = status === APP_ACTIVE ? pomodoroDuration : breakDuration;\n  let timeElapsed = Math.floor((now - checkpoint) / 1000);\n  let timeRemaining = Math.floor(duration - timeElapsed);\n  let time = countup ? timeElapsed : timeRemaining;\n  if (time < 0) {\n    time = Math.abs(time);\n    negative = true;\n  }\n  let { hours, minutes, seconds } = partitionTime(time);\n\n  setTimeout(() => {\n    if (\n      appState.status !== status ||\n      appState.checkpoint !== checkpoint ||\n      appState.countup !== countup ||\n      appState.pomodoroDuration !== pomodoroDuration ||\n      appState.breakDuration !== breakDuration ||\n      appState.speaker !== speaker\n    )\n      return;\n    update({ renderSignal: renderSignal + 1, prevTimeRemaining: timeRemaining });\n  }, 400);\n\n  if (isLeader()) {\n    if (status === APP_BREAK) {\n      if (prevTimeRemaining > 0 && timeRemaining <= 0) {\n        playSpeech(`public/speech/break_over_${appState.speaker}.mp3`);\n      }\n    }\n    if (status === APP_ACTIVE) {\n      if (prevTimeRemaining > 0 && timeRemaining <= 0) {\n        playSpeech(`public/speech/break_start_${appState.speaker}.mp3`);\n      }\n    }\n  }\n\n  let className = 'pomodoro';\n  let label = '';\n  if (editing) label = editingValue;\n  else {\n    if (negative || (countup && time > duration)) className += ' elapsed';\n    label = formatTime(\n      { hours, minutes, seconds },\n      { forceMinutes: true, forceSeconds: true, pad: 2 },\n    );\n    if (negative) label = '-' + label;\n  }\n\n  return div(\n    { class: 'pomodoro-wrapper' },\n    button({ class: 'flip-icon', onclick: flipCountDirection }, '\u2B83'),\n    input({\n      class: className,\n      value: label,\n      oninput: (e) => {\n        update({ editing: true, editingValue: e.target.value });\n      },\n      onblur: (e) => {\n        if (editing) updateTimerFromInput(e);\n      },\n      onkeydown: (e) => {\n        if (e.key === ENTER && editing) updateTimerFromInput(e);\n        if (e.key === ARROW_UP) navigateEl(e.target, Direction.Up);\n        if (e.key === ARROW_DOWN) navigateEl(e.target, Direction.Down);\n      },\n    }),\n  );\n}\n\nconst audioView = (props: AppState) => {\n  if (props.audioUploadState === 1) {\n    let className = 'audio-controls';\n    if (props.draggingFile) className += ' dragging-file';\n    return div(\n      {\n        className,\n        ...audioDropHandlers,\n      },\n      h('label', { for: 'audio-upload' }, 'Upload Audio'),\n      input({\n        id: 'audio-upload',\n        type: 'file',\n        multiple: true,\n        accept: 'audio/*',\n        onchange: (e) => {\n          uploadAudioFiles((files) => handleAudioUpload(files))(e);\n        },\n        ...audioDropHandlers,\n      }),\n      button(\n        {\n          onclick: () => {\n            audioStore.clear();\n          },\n          ...audioDropHandlers,\n        },\n        'Delete Audio',\n      ),\n    );\n  } else {\n    return div(\n      {\n        className: 'audio-controls',\n      },\n      div({ className: 'progress', style: { width: props.audioUploadState * 100 + '%' } }),\n    );\n  }\n};\n\nfunction appView(props: AppState) {\n  if (props.status === APP_IDLE || props.sessionTasks.list.length === 0) {\n    return div(\n      { className: 'tasks-bar' },\n      h(sessionButtonView, {\n        onclick: () => {\n          playShuffledAudio();\n          startSession();\n        },\n        label: 'Start Session',\n      }),\n      h(sessionTasksView, { key: 'session', ...props }),\n      h(recurringTasksView, { key: 'recurring', ...props }),\n      h(completedTasksView, { key: 'completed', ...props }),\n      h(audioView, props),\n    );\n  } else {\n    return div(\n      { className: 'tasks-bar' },\n      // pomodoro timer\n      h(pomodoroTimerView, props),\n      // buttons\n      props.status === APP_ACTIVE\n        ? h(sessionButtonView, {\n            onclick: () => {\n              stopMusic();\n              breakSession();\n            },\n            label: 'Take Break',\n          })\n        : h(sessionButtonView, {\n            onclick: () => {\n              playShuffledAudio();\n              resumeSession();\n            },\n            label: 'Resume',\n          }),\n      span({}, ' '),\n      h(sessionButtonView, {\n        onclick: () => {\n          stopMusic();\n          endSession();\n        },\n        label: 'End Session',\n      }),\n      // active task\n      h(activeTaskView, { key: 'active', activeTask: props.sessionTasks.list[0] }),\n      // task lists\n      h(sessionTasksView, {\n        key: 'session',\n        ...props,\n        sessionTasks: { list: props.sessionTasks.list.slice(1) },\n      }),\n      h(recurringTasksView, { key: 'recurring', ...props }),\n      h(completedTasksView, { key: 'completed', ...props }),\n      h(audioView, props),\n    );\n  }\n}\n\n// RENDER\n////////////////////////////////////////////////////////////////////////////////\n\nconst root = document.getElementById('app') as DNode;\nrender(h(appView, appState), root);\n\nfunction redraw() {\n  console.log('redraw');\n  diff(h(appView, appState), root, root._vnode!);\n}\n\ncallback.onChange = redraw;\n"],
  "mappings": "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",
  "names": ["h", "ib", "fb", "ia", "fa", "i", "channel", "options", "callback", "storeTask", "dom", "options", "getNavigableElements", "closest", "e", "sessionTasks", "recurringTasks", "completedTasks", "time"]
}
